# RSA 暗号について
## 秘密鍵と公開鍵の普通の作り方
1. p と q をランダムに選ぶ(ただし、p と q はともに素数)
2. N = pq とすると、φ(N) = (p - 1)(q - 1)
3. GCD(e, φ(N)) = 1 かつ 0 < e < N を満たす e を選ぶ
4. ed mod φ(N) = 1 かつ 0 < e < N を満たす d を選ぶ
5. N, e を公開鍵とし、d を秘密鍵とする

## N　を因数分解して頑張る
`./msieve -e -v -q (N の数)`  で因数分解して p と q を求める

## e が極端に小さいとき (e = 3)
c + i * N が　e乗根　できちんと計算できるとき、(`m,result = gmpy2.iroot(a,e)` で result が true　のとき)  m が求める平文である。


## d が小さいとき
Wiener's Attack を使って、秘密鍵を求めることができる
```python
import owiener

e = 1030280624861040313586836742583878831513291335603905561886525125156168740109770705682574073212285776271206165328642818619858847613283733496680839245917276100034185215145390820406363701411080838042164379611426920418074932445667262384999945969903997217161433019113710422129170650867027116325701086670082336701
n = 113361070359432730904432178104664421955346065019260495670863758555551863585032997345941588192249861535146381255918808341238897535094221159470933236849452362628500027499331489405301278220820709898828915904047366512994648468631099438723751995911021940307614121356146742608262386590729771302137128920195458638889
d = owiener.attack(e, n)

if d is None:
    print("Failed")
else:
    print("Hacked d={}".format(d))

```

>> 数学的理解がまだ中途半端なので時間があるときにじっくり考えたい。今回はただライブラリを使っただけ、
